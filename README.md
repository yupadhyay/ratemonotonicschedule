# ratemonotonicschedule
Rate Monotonic Scheduling in Unix
Linux currently supports three kind of scheduling class SCHED_RR (For Round Robin scheduling), SCHED_FIFO (For first in First out) and SCHED_OTHER (For all other processes).These classes are arranged on the basis of there priorities, with SCHED_RR having highest priority (most of the real time processes falls in to this category ,Though there is more than just priority, like each processes, apart of being having static priority has dynamic priorities that can be computed during run time depending upon how much time a process has actually taken while execution and for how much time process is not executing). The goal of this assignment was to implement new shceduling algorithem SCHED_PERIODIC_RT that support Rate Monotonic Scheduling (RMS) policy for hard time real time time processes. In RMS each process has some computation time and time period (deadline). Each process should complete there computation before this deadline. RMS processes has highest priority in the system and hence care should be taken that they should not starve other real time processes (Like console and UI processes). To do this only 70-80% of CPU cycle is alloted to the RMS processes. Also before admitting any process (Through sched_setscheduler(pid,policy,sched_priority) system call) as RMS processes, check should be made to ensure that submitting this process should not cause deadline miss for other RMS processes. to check this admission control criteria one can use the formula SUM Ti/Tj*Cj+Ci<=Ti for all j from 1 to i-1 and do this computation recursively till all the processes from 2 to N , where Ti= time period of process under question, Ci=computaion time, Tj=time period of process before Ti, Cj=computation time for jth process. If submission of a process cause deadline miss for any of the existing RMS process that process should not get submitted. Other thing needs to be taken care of is that everytime a higher priority process (Process with low time period T has higher priority) within RMS is eligible to run (It's time period is over), current running process should ger preemted and higher priority process should run (This operation of preemption include task switching overhead within the kernel that should be accomodated and taken care of by yielding processes to CPU once computation is finished before it's computation time). It has been observe that deadline miss (RMS process not able to finish there computation before time T) can be seen when the utilization factor (SUM Ci/Ti) is high. 
